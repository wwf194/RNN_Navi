{
    "Type": "RNNLIF",
    "InitTasks":[
        {
            "Type": "FunctionCall",
            "Args":[
                //"&*InitModules"
            ]
        }
    ],
    "Neurons":{
        "Input":{
            "Num":"$^param.agent.model.Input.Num"
        },
        "Recurrent":{
            "ExciInhi":{
                "Enable": true,
                "Weight": [
                    "&Modules.Recurrent.Weight",
                    "&Modules.Output.Weight"
                ]
            },
            "Num": 2048,
            "Excitatory":{
                "Ratio": 0.8
            },
            "Inhibitory":{},
            "NonLinear":"ReLU"
        },
        "Output":{
            "Num": "$Neurons.Recurrent.Num // 4"
        },
        "Num": "$Neurons.Recurrent.Num"
    },
    "Loss":{
        "WeightConstrain":{
            "Coefficient.__value__":"Adaptive",
            "Coefficient":{
                "Method": "Ratio2RefLoss",
                "Ratio": [0.05, 0.15],
                "Reference": "&Modules.CalculatePredictionLoss",
            },
            "Weight":[
                "&*cache.Modules.Recurrent.FiringRate2RecurrentInput.GetWeight",
                "&*cache.Modules.Recurrent.FiringRate2Output.GetWeight"
            ],
        },
        "ActivityConstrain":{
            "Coefficient.__value__":"Adaptive",
            "Coefficient":{
                "Method": "Ratio2RefLoss",
                "Ratio": [0.05, 0.15],
                "Reference": "&Modules.CalculatePredictionLoss",
            },
            "Activity":[ // to be implemented.
                "cellStates", "hiddenStates"
            ]
        },
        "Prediction":{
            "Coefficient": 1.0,
            "Type": "MeanSquareError",
        }
    },
    "Modules":{
        "Recurrent":{
            "Type":"RecurrentLIFLayer",
            "Subtype":"f(Wx+b)",
            "Weight":{
                "Size":["$Neurons.Recurrent.Num", "$Neurons.Recurrent.Num"],
                "Init":{
                    "Method": "kaiming",
                    "Coefficient": 1.0e-1
                }
            },
            "TimeConstance": 0.1,
            "Modules":{
                "NonLinear":{
                    "Subtype":"$Neurons.Recurrent.NonLinear",
                },
                "FiringRate2RecurrentInput":{
                    "Type": "LinearLayer",
                    "Subtype": "Wx",
                    "IsExciInhi": "$Neurons.Recurrent.IsExciInhi",
                    "Input.Num": "$Neurons.Recurrent.Num",
                    "Output.Num": "$Neurons.Recurrent.Num",
                },
                "FiringRate2Output":{
                    "Type": "LinearLayer",
                    "Subtype": "Wx+b",
                    "IsExciInhi": "$Neurons.Recurrent.IsExciInhi",
                    "Input.Num": "$Neurons.Recurrent.Num",
                    "Output.Num": "$Neurons.Output.Num",                    
                },
                "CellStateDecay":{
                    "Type": "Internal",
                    "IsExciInhi": "$Neurons.Recurrent.IsExciInhi",
                },
                "NoiseGenerator":{
                    "Distribution": "Gaussian",
                    "Method": "Adaptive",
                    "SubMethod": "FromInputStd",
                    "StdRatio": 0.05,
                },
                "GetBias": {
                    "Type": "Bias",
                    "Size": "$Neurons.Recurrent.Num"
                },
            },
            "Dynamics":{
                "__Entry__":"&Dynamics.Main",
                "Main":{
                    "In": ["recurrentInput", "cellState", "input"],
                    "Out": ["recurrentInputNext", "cellStateNext", "firingRate", "output"],
                    "Routings":[
                        "&GetBias |--> bias",
                        "recurrentInput, input, bias |--> &Add |--> inputTotal",
                        "inputTotal |--> &NoiseGenerator |--> noise",
                        "inputTotal, noise |--> &Add |--> inputTotal",
                        "inputTotal, cellState |--> &ProcessCellStateAndTotalInput |--> cellState",
                        "cellState |--> &NonLinear |--> firingRate",
                        "firingRate |--> &FiringRate2RecurrentInput |--> recurrentInputNext",
                        "firingRate |--> &FiringRate2Output |--> output",
                        "cellState |--> &CellStateDecay |--> cellStateNext",
                    ]
                },
            }
        },
        "Output":{
            "Type":"LinearLayer",
            "Subtype": "Wx+b",
            "Input.Num": "$Neurons.Recurrent.Num",
            "Output.Num": "$Neurons.Output.Num",
            "Weight.Init":{
                "Method": "kaiming",
                "Coefficient": 1.0e-1
            },
            "Bias":true,
            //"NonLinear":"$Neurons.Recurrent.NonLinear"
        },
        "Input":{
            "Type": "NonLinearLayer",
            "Subtype":"f(Wx+b)",
            "Input.Num":"$Neurons.Input.Num",
            "Output.Num":"$Neurons.Recurrent.Num",
            "Weight":{
                "Init":{
                    "Method": "kaiming",
                    "Coefficient": 1.0e-1
                }
            },
            "Bias": true,
            "NonLinear":"$Neurons.Recurrent.NonLinear"
        },
        "InputInit2StateInit":{
            "Type":"MLP",
            "Output.":"$Neurons.Recurrent.Num",
            "Init.Method":"FromNeuronNum",
            "Neurons":{
                "Num":[
                    "$^param.agent.model.InputInit.Num",
                    "$Neurons.Recurrent.Num ",
                    "$Neurons.Recurrent.Num * 2"
                ]
            },
            "Layers":{
                "Num": "len($Modules.InputInit2StateInit.Neurons.Num) - 1",
                "NonLinear": "$Neurons.Recurrent.NonLinear",
                "Bias": true,
                "NonLinearOnLastLayer": false,
            }
        },
        "Splitter":{
            "Type": "Lambda",
            "Lambda": "lambda data: [data[:, :($Neurons.Recurrent.Num)], data[:, ($Neurons.Recurrent.Num):]]"
        },
        "Inputs":{
            "Type":"SerialSender",
            "Send":{
                "Method": "Lambda",
                "Args": "lambda List, Index: List[:, Index, :]"
            }
        },
        "Outputs":{
            "Type":"SerialReceiver",
            "Send":{
                "Method": "Lambda",
                //"Args": "lambda List, Index:torch.take(input=List, index=Index, axis=1)" //torch.take requires index to be LongTensor
                "Args": "lambda List:torch.stack(List, axis=1)"
            }
        },
        "HiddenStates":{
            "Type": "SerialReceiver",
            "Send":{
                "Method": "Lambda",
                "Args": "lambda List:torch.stack(List, axis=1)"
            }
        },
        "CellStates":{
            "Type": "SerialReceiver",
            "Send":{
                "Method": "Lambda",
                "Args": "lambda List:torch.stack(List, axis=1)"
            }
        },
        "FiringRates":{
            "Type": "SerialReceiver",
            "Send":{
                "Method": "Lambda",
                "Args": "lambda List:torch.stack(List, axis=1)"
            }
        },
        "PredictionLoss": "$Loss.Prediction",
        "GetConstrainWeight":{
            "Type": "FunctionsOutputs",
            "Functions": "$Loss.WeightConstrain.Weight"
        },
        "WeightConstrainLoss":{
            "Type": "L2Loss",
            "Coefficient": "$Loss.WeightConstrain.Coefficient",
        },
        "ActivityConstrainLoss":{
            "Type": "L2Loss",
            "Coefficient": "$Loss.ActivityConstrain.Coefficient",
        },
    },
    "Dynamics":{
        "Run":{
            "In":["inputInit", "inputSeries", "time"],
            "Out":["OutputSeries"],
            "Routings":[
                "inputSeries |--> &Inputs.Receive",
                "inputInit |--> &InputInit2StateInit |--> state",
                "state |--> &Splitter |--> hiddenState, cellState",
                "hiddenState, cellState |--> &Iterate |--> hiddenState, cellState || repeat=%time",
                "&Outputs.Send |--> OutputSeries"
            ]
        },
        "Iterate":{
            "In":["hiddenState", "cellState"],
            "Out":["hiddenState", "cellState"],
            "Routings":[
                "&Inputs.Send |--> input",
                "input |--> &Input |--> inputProcessed",
                "hiddenState, cellState, inputProcessed |--> &Recurrent |--> hiddenState, cellState, output, firingRate",
                "output |--> &Outputs.Receive",
                "hiddenState |--> &HiddenStates.Receive",
                "cellState |--> &CellStates.Receive"
            ]
        },
        "IterateTrain":{
            "In":["hiddenState", "cellState"],
            "Out":["hiddenState", "cellState"],
            "Routings":[
                "&Inputs.Send |--> input",
                "input |--> &Input |--> inputProcessed",
                "hiddenState, cellState, inputProcessed |--> &Recurrent |--> hiddenState, cellState, firingRate, output",
                "output |--> &Outputs.Receive",
                "hiddenState |--> &HiddenStates.Receive",
                "cellState |--> &CellStates.Receive",
                "firingRate |--> &FiringRates.Receive",
            ]
        },
        "RunTrain":{
            "In":["inputInit", "inputSeries", "time"],
            "Out":["outputSeries", "hiddenStateSeries", "cellStateSeries", "firingRateSeries"],
            "Routings":[
                "inputSeries |--> &Inputs.Receive",
                "inputInit |--> &InputInit2StateInit |--> state",
                "state |--> &Splitter |--> hiddenState, cellState",
                "hiddenState, cellState |--> &IterateTrain |--> hiddenState, cellState || repeat=%time",
                "&Outputs.Send |--> outputSeries",
                "&HiddenStates.Send |--> hiddenStateSeries",
                "&CellStates.Send |--> cellStateSeries",
                "&FiringRates.Send |--> firingRateSeries",
            ]
        },
        "Train":{
            "In":["input", "outputTarget", "trainParam"],
            "Out":[],
            "Routings":[
                "input |--> &Split |--> inputInit, inputSeries, time",
                "inputInit, inputSeries, time |--> &RunTrain |--> outputSeries, hiddenStateSeries, cellStateSeries, firingRateSeries",
                "hiddenStateSeries, cellStateSeries, firingRateSeries |--> &Merge |--> activity",
                "outputSeries, outputTarget, activity, trainParam |--> &Optimize",
            ]
        },
        "Optimize":{
            "In": ["output", "outputTarget", "activity", "trainParam"],
            "Routings":[
                "output, outputTarget |--> &PredictionLoss |--> mainLoss",
                "activity, mainLoss |--> &CalculateActivityConstrainLoss |--> activityConstrainLoss",
                "mainLoss |--> &CalculateWeightConstrainLoss |--> weightConstrainLoss",
                "mainLoss, activityConstrainLoss, weightConstrainLoss |--> &Add |--> totalLoss",
                "totalLoss |--> &CalculateGradient",
                "&*GetTrainWeight |--> trainWeight",
                "trainWeight, trainParam |--> &GradientDescend"
            ],
        },
        "CalculateWeightConstrainLoss":{
            "In": ["refLoss"],
            "Out": ["weightConstrainLoss"],
            "Routings":[
                "&GetConstrainWeight |--> weightConstrain",
                "weightConstrain, refLoss |--> &WeightConstrainLoss |--> weightConstrainLoss"
            ]
        },
        "CalculateActivityConstrainLoss":{
            "In": ["activity", "refLoss"],
            "Out": ["activityConstrainLoss"],
            "Routings":[
                "activity, refLoss |--> &ActivityConstrainLoss |--> activityConstrainLoss"
            ]
        },
        "__Entry__":"&Dynamics.Run"
    },
}